dining philosopher için bir program yazdım ama hatalar var sanırım. elimdeki dosyalar: #ifndef PHILO_H # define PHILO_H  # include <stdio.h> # include <stdlib.h> # include <unistd.h> # include <pthread.h> # include <sys/time.h> # include <string.h>  # define FORK_MSG "has taken a fork" # define EAT_MSG "is eating" # define SLEEP_MSG "is sleeping" # define THINK_MSG "is thinking" # define DIED_MSG "died"  typedef struct s_philo { 	int				id; 	int				meals_eaten; 	long long		last_meal_time; 	pthread_t		thread; 	pthread_mutex_t	*left_fork; 	pthread_mutex_t	*right_fork; 	struct s_data	*data; }	t_philo;  typedef struct s_data { 	int				philo_count; 	long long		time_to_die; 	long long		time_to_eat; 	long long		time_to_sleep; 	int				must_eat_count; 	int				finished_eating; 	int				someone_died; 	long long		start_time; 	pthread_mutex_t	*forks; 	pthread_mutex_t	print_mutex; 	pthread_mutex_t	death_mutex; 	pthread_mutex_t	meal_mutex; 	t_philo			*philos; }	t_data;  // utils.c long long	get_time(void); void		smart_sleep(long long time); void		print_status(t_philo *philo, char *status); int			ft_atoi(const char *str);  // init.c int			init_data(t_data *data, int argc, char **argv); int			init_philos(t_data *data); int			init_mutexes(t_data *data);  // philo.c void		*philosopher_routine(void *arg); void		philo_eat(t_philo *philo); void		philo_sleep(t_philo *philo); void		philo_think(t_philo *philo);  // monitor.c void		*monitor_routine(void *arg); int			check_death(t_data *data); int			check_meals(t_data *data);  // main.c int			main(int argc, char **argv); void		cleanup(t_data *data); int			start_simulation(t_data *data);  #endif,  #include "philo.h"  int	main(int argc, char **argv) { 	t_data	data;  	if (argc < 5 || argc > 6) 	{ 		printf("Usage: %s number_of_philosophers time_to_die time_to_eat", argv[0]); 		printf(" time_to_sleep [number_of_times_each_philosopher_must_eat]\n"); 		return (1); 	} 	if (init_data(&data, argc, argv) != 0) 		return (1); 	if (init_philos(&data) != 0) 	{ 		cleanup(&data); 		return (1); 	} 	if (start_simulation(&data) != 0) 	{ 		cleanup(&data); 		return (1); 	} 	cleanup(&data); 	return (0); }  int	start_simulation(t_data *data) { 	int			i; 	pthread_t	monitor_thread;  	data->start_time = get_time(); 	i = 0; 	while (i < data->philo_count) 	{ 		data->philos[i].last_meal_time = data->start_time; 		if (pthread_create(&data->philos[i].thread, NULL,  			philosopher_routine, &data->philos[i]) != 0) 			return (1); 		i++; 	} 	if (pthread_create(&monitor_thread, NULL, monitor_routine, data) != 0) 		return (1); 	pthread_join(monitor_thread, NULL); 	i = 0; 	while (i < data->philo_count) 	{ 		pthread_join(data->philos[i].thread, NULL); 		i++; 	} 	return (0); }  void	cleanup(t_data *data) { 	int	i;  	if (data->forks) 	{ 		i = 0; 		while (i < data->philo_count) 		{ 			pthread_mutex_destroy(&data->forks[i]); 			i++; 		} 		free(data->forks); 	} 	pthread_mutex_destroy(&data->print_mutex); 	pthread_mutex_destroy(&data->death_mutex); 	pthread_mutex_destroy(&data->meal_mutex); 	if (data->philos) 		free(data->philos); }   , #include "philo.h"  int	init_data(t_data *data, int argc, char **argv) { 	memset(data, 0, sizeof(t_data)); 	data->philo_count = ft_atoi(argv[1]); 	data->time_to_die = (long long)ft_atoi(argv[2]); 	data->time_to_eat = (long long)ft_atoi(argv[3]); 	data->time_to_sleep = (long long)ft_atoi(argv[4]); 	if (argc == 6) 		data->must_eat_count = ft_atoi(argv[5]); 	else 		data->must_eat_count = -1; 	 	if (data->philo_count <= 0 || data->time_to_die < 0 ||  		data->time_to_eat < 0 || data->time_to_sleep < 0) 	{ 		printf("Error: Invalid arguments\n"); 		return (1); 	} 	if (argc == 6 && data->must_eat_count <= 0) 	{ 		printf("Error: Invalid number of meals\n"); 		return (1); 	} 	return (init_mutexes(data)); }  int	init_mutexes(t_data *data) { 	int	i;  	if (pthread_mutex_init(&data->print_mutex, NULL) != 0) 		return (1); 	if (pthread_mutex_init(&data->death_mutex, NULL) != 0) 		return (1); 	if (pthread_mutex_init(&data->meal_mutex, NULL) != 0) 		return (1); 	data->forks = malloc(sizeof(pthread_mutex_t) * data->philo_count); 	if (!data->forks) 		return (1); 	i = 0; 	while (i < data->philo_count) 	{ 		if (pthread_mutex_init(&data->forks[i], NULL) != 0) 			return (1); 		i++; 	} 	return (0); }  int	init_philos(t_data *data) { 	int	i;  	data->philos = malloc(sizeof(t_philo) * data->philo_count); 	if (!data->philos) 		return (1); 	i = 0; 	while (i < data->philo_count) 	{ 		data->philos[i].id = i + 1; 		data->philos[i].meals_eaten = 0; 		data->philos[i].last_meal_time = 0; 		data->philos[i].data = data; 		data->philos[i].left_fork = &data->forks[i]; 		data->philos[i].right_fork = &data->forks[(i + 1) % data->philo_count]; 		i++; 	} 	return (0); }, #include "philo.h"  void	*philosopher_routine(void *arg) { 	t_philo	*philo;  	philo = (t_philo *)arg; 	 	// Tek filozof durumu - sadece bekleyip ölecek 	if (philo->data->philo_count == 1) 	{ 		print_status(philo, FORK_MSG); 		smart_sleep(philo->data->time_to_die + 1); 		return (NULL); 	} 	 	if (philo->id % 2 == 0) 		smart_sleep(philo->data->time_to_eat / 2); 	while (1) 	{ 		pthread_mutex_lock(&philo->data->death_mutex); 		if (philo->data->someone_died) 		{ 			pthread_mutex_unlock(&philo->data->death_mutex); 			break ; 		} 		pthread_mutex_unlock(&philo->data->death_mutex); 		philo_eat(philo); 		philo_sleep(philo); 		philo_think(philo); 	} 	return (NULL); }  void	philo_eat(t_philo *philo) { 	pthread_mutex_lock(&philo->data->death_mutex); 	if (philo->data->someone_died) 	{ 		pthread_mutex_unlock(&philo->data->death_mutex); 		return ; 	} 	pthread_mutex_unlock(&philo->data->death_mutex); 	 	// Tek filozof özel durumu 	if (philo->data->philo_count == 1) 	{ 		pthread_mutex_lock(philo->left_fork); 		print_status(philo, FORK_MSG); 		pthread_mutex_unlock(philo->left_fork); 		return ; 	} 	 	// Deadlock prevention: çift id'ler farklı sırada alır 	if (philo->id % 2 == 1) 	{ 		pthread_mutex_lock(philo->left_fork); 		print_status(philo, FORK_MSG); 		pthread_mutex_lock(philo->right_fork); 		print_status(philo, FORK_MSG); 	} 	else 	{ 		pthread_mutex_lock(philo->right_fork); 		print_status(philo, FORK_MSG); 		pthread_mutex_lock(philo->left_fork); 		print_status(philo, FORK_MSG); 	} 	 	pthread_mutex_lock(&philo->data->meal_mutex); 	philo->last_meal_time = get_time(); 	pthread_mutex_unlock(&philo->data->meal_mutex); 	 	print_status(philo, EAT_MSG); 	smart_sleep(philo->data->time_to_eat); 	 	pthread_mutex_lock(&philo->data->meal_mutex); 	philo->meals_eaten++; 	pthread_mutex_unlock(&philo->data->meal_mutex); 	 	pthread_mutex_unlock(philo->left_fork); 	pthread_mutex_unlock(philo->right_fork); }  void	philo_sleep(t_philo *philo) { 	pthread_mutex_lock(&philo->data->death_mutex); 	if (philo->data->someone_died) 	{ 		pthread_mutex_unlock(&philo->data->death_mutex); 		return ; 	} 	pthread_mutex_unlock(&philo->data->death_mutex); 	 	print_status(philo, SLEEP_MSG); 	smart_sleep(philo->data->time_to_sleep); }  void	philo_think(t_philo *philo) { 	pthread_mutex_lock(&philo->data->death_mutex); 	if (philo->data->someone_died) 	{ 		pthread_mutex_unlock(&philo->data->death_mutex); 		return ; 	} 	pthread_mutex_unlock(&philo->data->death_mutex); 	 	print_status(philo, THINK_MSG); }, #include "philo.h"  void	*monitor_routine(void *arg) { 	t_data	*data;  	data = (t_data *)arg; 	while (1) 	{ 		// Önce yemek sayısını kontrol et - daha önemli 		if (check_meals(data)) 			break ; 		// Sonra ölüm kontrolü 		if (check_death(data)) 			break ; 		usleep(50); 	} 	return (NULL); }  int	check_death(t_data *data) { 	int			i; 	long long	current_time;  	i = 0; 	current_time = get_time(); 	while (i < data->philo_count) 	{ 		pthread_mutex_lock(&data->meal_mutex); 		if (current_time - data->philos[i].last_meal_time > data->time_to_die) 		{ 			pthread_mutex_unlock(&data->meal_mutex); 			pthread_mutex_lock(&data->death_mutex); 			data->someone_died = 1; 			pthread_mutex_unlock(&data->death_mutex); 			pthread_mutex_lock(&data->print_mutex); 			current_time = get_time() - data->start_time; 			printf("%lld %d %s\n", current_time, data->philos[i].id, DIED_MSG); 			pthread_mutex_unlock(&data->print_mutex); 			return (1); 		} 		pthread_mutex_unlock(&data->meal_mutex); 		i++; 	} 	return (0); }  int	check_meals(t_data *data) { 	int	i; 	int	all_finished;  	if (data->must_eat_count == -1) 		return (0); 	 	all_finished = 1; 	i = 0; 	while (i < data->philo_count) 	{ 		pthread_mutex_lock(&data->meal_mutex); 		if (data->philos[i].meals_eaten < data->must_eat_count) 			all_finished = 0; 		pthread_mutex_unlock(&data->meal_mutex); 		if (!all_finished) 			break ; 		i++; 	} 	 	if (all_finished) 	{ 		pthread_mutex_lock(&data->death_mutex); 		data->someone_died = 1; 		pthread_mutex_unlock(&data->death_mutex); 		return (1); 	} 	return (0); }, #include "philo.h"  long long	get_time(void) { 	struct timeval	tv;  	gettimeofday(&tv, NULL); 	return ((tv.tv_sec * 1000) + (tv.tv_usec / 1000)); }  void	smart_sleep(long long time) { 	long long	start;  	start = get_time(); 	while (get_time() - start < time) 		usleep(500); }  void	print_status(t_philo *philo, char *status) { 	long long	timestamp;  	pthread_mutex_lock(&philo->data->print_mutex); 	pthread_mutex_lock(&philo->data->death_mutex); 	if (!philo->data->someone_died) 	{ 		timestamp = get_time() - philo->data->start_time; 		printf("%lld %d %s\n", timestamp, philo->id, status); 	} 	pthread_mutex_unlock(&philo->data->death_mutex); 	pthread_mutex_unlock(&philo->data->print_mutex); }  int	ft_atoi(const char *str) { 	int	result; 	int	sign; 	int	i;  	result = 0; 	sign = 1; 	i = 0; 	while (str[i] == ' ' || (str[i] >= 9 && str[i] <= 13)) 		i++; 	if (str[i] == '-' || str[i] == '+') 	{ 		if (str[i] == '-') 			sign = -1; 		i++; 	} 	while (str[i] >= '0' && str[i] <= '9') 	{ 		result = result * 10 + (str[i] - '0'); 		i++; 	} 	return (result * sign); }, testera soktuğumda aldığım çıktı da şöyle: 